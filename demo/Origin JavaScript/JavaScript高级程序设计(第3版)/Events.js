
// 事件
// 
// 理解事件流
// 使用事件处理程序
// 不同的事件类型





// 事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间，
// 可以使用侦听器(或处理程序)来预订事件，以便事件发生时执行相应的代码。
// 这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript 代码）与页
// 面的外观（HTML 和CSS 代码）之间的松散耦合。


// 事件流
// 页面的哪一部分会拥有某个特定的事件？
// 要明白这个问题问的是什么，可以想象画在一张纸上的一组同心圆。
// 如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。


// 事件流：从页面中接收事件的顺序。
// 初期IE事件流：事件冒泡流
// Netcape Communicator事件流：事件捕获流

/*
事件冒泡
 - IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深
   的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）

	冒泡会一直冒泡到window对象

	内 ——> 外

*/

/*
事件捕获
 - 事件捕获的思想
是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在
事件到达预定目标之前捕获它。
	
	DOM2级事件 规范要求 document对象开始传播

	现代浏览器从window对象开始捕获事件
	
	外 ——> 内

 */

// 事件冒泡兼容性更好，建议优先使用事件冒泡

/*
DOM事件流
	- “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。
		首先发生的是事件捕获，为截获事件提供了机会。
		然后是实际的目标接收到事件。
		最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。
	

	Document  Element[html] 	Element[body]	Element[div]
	
	时间的目标在捕获阶段不会接受到事件，捕获阶段到达Element[body]就停止了，
	下一阶段是"处于目标"阶段，事件在目标<div>上发生，并在事件处理中被看成冒泡阶段的一部分。
	然后，冒泡阶段发生阶段发生了，事件又传输回文档。

	DOM2级事件 要求捕获阶段不会涉及事件目标
	现代浏览器都会在捕获阶段触发对象上的事件，结果，就是有两个机会在目标对象上面操作事件。

 */

// 事件处理程序
// 事件就是用户或浏览器自身执行的某种动作。
// 响应某个事件的函数就叫做事件处理程序(或事件侦听器)
// 事件处理程序的名字以"on"开头，click —> onclick，load —> onload




// 为事件指定处理程序方式：

// 1、HTML事件处理程序
/*
某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML 特性来指定。这个
特性的值应该是能够执行的JavaScript 代码。

不能在其中使用未经转义的HTML 语法字符，如<>/""等

在HTML 中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的
脚本，

事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。

这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个
函数中有一个局部变量event，也就是事件对象

通过event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。
在这个函数内部，this 值等于事件的目标元素

关于这个动态创建的函数，另一个有意思的地方是它扩展作用域的方式。在这个函数内部，可以像
访问局部变量一样访问document 及该元素本身的成员。	这个函数使用with

使用(with) - 实际上，这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段。

在HTML 中指定事件处理程序有两个缺点。首先，存在一个时差问题。因为用户可能会在
HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件
另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同JavaScript
引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错
通过HTML 指定事件处理程序的最后一个缺点是HTML 与JavaScript 代码紧密耦合。如果要更换事
件处理程序，就要改动两个地方：HTML 代码和JavaScript 代码
*/




// 2、DOM0 事件处理程序

/*
	通过JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性
	为所有现代浏览器所支持。 原因一是简单，二是具有跨浏览器的优势。

	要使用JavaScript 指定事件处理程序，首先必须取得一个要操作的对象的引用。
	每个元素（包括window 和document）都有自己的事件处理程序属性，这些属性通常全部小写，
	例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序。

	使用DOM0 级方法指定的事件处理程序被认为是元素的方法。
	因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，程序中的this 引用当前元素。

	也可以删除通过DOM0 级方法指定的事件处理程序，只要像下面这样将事件处理程序属性的值设
	置为null 即可：
	btn.onclick = null; //删除事件处理程序
	将事件处理程序设置为null 之后，再单击按钮将不会有任何动作发生
*/




// 3、DOM2 级事件处理程序

/*
	用于处理指定和删除事件处理程序的操作：addEventListener()/removeEventListener()
	所有节点都包含这两个方法，接受3个参数：
			- 要处理的事件名
			- 作为事件处理程序的函数
			- 一个布尔值：true -> 捕获阶段调用事件处理程序，false -> 冒泡阶段调用事件处理程序

	这里添加的事件处理程序也是在其依附的元素的作用域中运行

	使用DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。

	通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移
	除时传入的参数与添加处理程序时使用的参数相同。
	addEventListener()添加的匿名函数将无法移除。

	大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。
	最好只在需要在事件到达目标之前截获它的时候将程序添加到捕获阶段。（这话很绕哦）
	如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。
*/



// 4、IE事件处理程序
/*
	IE实现与DOM中类似的两个方法：attachEvent()/detachEvent()
	接受两个参数：事件处理程序名称与事件处理程序函数
	通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。
		
		attachEvent()的第一个参数是"onclick"，而非DOM 的addEventListener()方法中的"click"。
	
	在IE 中使用attachEvent()与使用DOM0 级方法的主要区别在于事件处理程序的作用域。在使
	用DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用attachEvent()方
	法的情况下，事件处理程序会在全局作用域中运行，因此this 等于window。
	
	DOM0/DOM2级方法 处理程序会在其所属元素的作用域内运行，this => element(当前)

	attachEventt() 事件处理程序会在全局作用域中运行，this => window
	
	为同一个按钮添加了两个不同的事件处理程序。
	不过，与DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发

	使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。
	与DOM 方法一样，这也意味着添加的匿名函数将不能被移除。
	不过，只要能够将对相同函数的引用传给detachEvent()，就可以移除相应的事件处理程序。

 */



// 5、跨浏览器的事件处理程序

/*
	能力检测
	只需要关注冒泡阶段
	
	addHandler()：视情况分别使用DOM0 级方法、DOM2 级方法 或 IE方法来添加事件。
				  归属EventUtil对象
				  接受3个参数：
				  	- 要操作的元素
					- 事件名称
					- 事件处理程序函数
	removeHandler(): 移除之前添加的事件处理程序，无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用DOM0级方法。
					 接受addHandler()相同的参数，
	
		这两个方法首先都会检测传入的元素中是否存在DOM2 级方法。如果存在DOM2 级方法，则使用
	该方法：传入事件类型、事件处理程序函数和第三个参数false（表示冒泡阶段）。如果存在的是IE 的
	方法，则采取第二种方案。注意，为了在IE8 及更早版本中运行，此时的事件类型必须加上"on"前缀。
	最后一种可能就是使用DOM0 级方法（在现代浏览器中，应该不会执行这里的代码）。此时，我们使用
	的是方括号语法来将属性名指定为事件处理程序，或者将属性设置为null。
	
	addHandler()和removeHandler()没有考虑到所有的浏览器问题，例如在IE 中的作用域问题。
	此外还要注意，DOM0 级对每个事件只支持一个事件处理程序。
 */




// 事件对象
/*
	在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。
	包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。
	
	所有浏览器都支持event 对象，但支持方式不同。

 */

// 1、DOM中的事件对象

// 2、IE中的事件对象

// 3、跨浏览器的事件对象



// 事件类型

/*
	"DOM3级事件"规定了以下几类事件：
	  - UI(User Interface)：用户与页面上的元素交互时触发
	  - 焦点时间：当元素获得或失去焦点时触发
	  - 鼠标时间：当用户通过鼠标在页面上执行操作触发
	  - 滚轮事件：当使用鼠标滚轮(或类似设备)时触发
	  - 文本事件：当在文档中输入文档时触发
	  - 键盘事件：当用户通过键盘在页面上执行操作时触发
	  - 合成事件：电脑管家IME(Input Method Editor, 输入法编辑器)输入字符时触发
	  - 变动(mutarion)事件：当底层DOM结构发生变化时触发

	DOM3 级事件模块在DOM2 级事件模块基础上重新定义了这些事件，也添加了一些新事件。
 */

// UI事件
	/*
	
	load:

	unload:

	abort:
	
	error:

	select:

	resize:

	scroll:



	 */
// 焦点事件

	/*
	
	blur:

	focus:

	focusin:

	focusout:

	 */

// 鼠标事件和滚轮事件

	/*
	
	click:

	dbclick:

	mousedown:

	mouseenter:

	mouseleave:

	mousemove:
	
	mousrout:

	mouseover:

	mouseup:
	
	MDN - 触摸事件
	https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events
	
	jack_孟 - JS移动客户端--触屏滑动事件
	http://www.cnblogs.com/mq0036/p/3934821.html

	touchstart: 手指放到屏幕上时触发

	touchmove: 手指在屏幕上滑动式触发

	touchend: 手指离开屏幕时触发

	touchcancel: 系统取消touch事件的时候触发，这个好像比较少用
	


	 */

// 文本和键盘事件
	/*
	keydown：

	keypress：

	keyup：

	textIput: 

	 */

// 合成事件
// 变动事件



